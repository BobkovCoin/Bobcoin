"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllExpressionTypes = exports.resolveExpression = exports.resolveLValueRef = exports.resolveConditional = exports.resolveInitOf = exports.getExpType = void 0;
const ast_1 = require("../grammar/ast");
const context_1 = require("../context");
const resolveDescriptors_1 = require("./resolveDescriptors");
const types_1 = require("./types");
const map_1 = require("../abi/map");
const global_1 = require("../abi/global");
const isAssignable_1 = require("./isAssignable");
const struct_1 = require("../abi/struct");
const store = (0, context_1.createContextStore)();
function getExpType(ctx, exp) {
    const t = store.get(ctx, exp.id);
    if (!t) {
        throw Error('Expression ' + exp.id + ' not found');
    }
    return t.description;
}
exports.getExpType = getExpType;
function registerExpType(ctx, exp, description) {
    const ex = store.get(ctx, exp.id);
    if (ex) {
        if ((0, types_1.typeRefEquals)(ex.description, description)) {
            return ctx;
        }
        throw Error('Expression ' + exp.id + ' already has a type');
    }
    return store.set(ctx, exp.id, { ast: exp, description });
}
function resolveBooleanLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, { kind: 'ref', name: 'Bool', optional: false });
}
function resolveIntLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, { kind: 'ref', name: 'Int', optional: false });
}
function resolveNullLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, { kind: 'null' });
}
function resolveStringLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, { kind: 'ref', name: 'String', optional: false });
}
function resolveStructNew(exp, sctx, ctx) {
    // Get type
    const tp = (0, resolveDescriptors_1.getType)(ctx, exp.type);
    if (tp.kind !== 'struct') {
        (0, ast_1.throwError)(`Invalid type "${exp.type}" for construction`, exp.ref);
    }
    // Process fields
    const processed = new Set();
    for (const e of exp.args) {
        // Check duplicates
        if (processed.has(e.name)) {
            (0, ast_1.throwError)(`Duplicate fields "${e.name}"`, e.ref);
        }
        processed.add(e.name);
        // Check existing
        const f = tp.fields.find((v) => v.name === e.name);
        if (!f) {
            (0, ast_1.throwError)(`Unknown fields "${e.name}" in type ${tp.name}`, e.ref);
        }
        // Resolve expression
        ctx = resolveExpression(e.exp, sctx, ctx);
        // Check expression type
        const expressionType = getExpType(ctx, e.exp);
        if (!(0, isAssignable_1.isAssignable)(expressionType, f.type)) {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(expressionType)}" for fields "${e.name}" with type ${(0, types_1.printTypeRef)(f.type)} in type ${tp.name}`, e.ref);
        }
    }
    // Check missing fields
    for (const f of tp.fields) {
        if (f.default === undefined && !processed.has(f.name)) {
            (0, ast_1.throwError)(`Missing fields "${f.name}" in type ${tp.name}`, exp.ref);
        }
    }
    // Register result
    return registerExpType(ctx, exp, { kind: 'ref', name: tp.name, optional: false });
}
function resolveBinaryOp(exp, sctx, ctx) {
    // Resolve left and right expressions
    ctx = resolveExpression(exp.left, sctx, ctx);
    ctx = resolveExpression(exp.right, sctx, ctx);
    const le = getExpType(ctx, exp.left);
    const re = getExpType(ctx, exp.right);
    // Check operands
    let resolved;
    if (exp.op === '-' || exp.op === '+' || exp.op === '*' || exp.op === '/' || exp.op === '%' || exp.op === '>>' || exp.op === '<<' || exp.op === '&' || exp.op === '|') {
        if (le.kind !== 'ref' || le.optional || le.name !== 'Int') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.ref);
        }
        if (re.kind !== 'ref' || re.optional || re.name !== 'Int') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
        }
        resolved = { kind: 'ref', name: 'Int', optional: false };
    }
    else if (exp.op === '<' || exp.op === '<=' || exp.op === '>' || exp.op === '>=') {
        if (le.kind !== 'ref' || le.optional || le.name !== 'Int') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.ref);
        }
        if (re.kind !== 'ref' || re.optional || re.name !== 'Int') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
        }
        resolved = { kind: 'ref', name: 'Bool', optional: false };
    }
    else if (exp.op === '==' || exp.op === '!=') {
        // Check if types are compatible
        if (le.kind !== 'null' && re.kind !== 'null') {
            const l = le;
            const r = re;
            if (l.kind === 'map' && r.kind === 'map') {
                if (l.key !== r.key || l.value !== r.value || l.keyAs !== r.keyAs || l.valueAs !== r.valueAs) {
                    (0, ast_1.throwError)(`Incompatible types "${(0, types_1.printTypeRef)(le)}" and "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
                }
            }
            else {
                if (l.kind === 'ref_bounced' || r.kind === 'ref_bounced') {
                    (0, ast_1.throwError)("Bounced types are not supported in binary operators", exp.ref);
                }
                if (l.kind !== 'ref' || r.kind !== 'ref') {
                    (0, ast_1.throwError)(`Incompatible types "${(0, types_1.printTypeRef)(le)}" and "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
                }
                if (l.name !== r.name) {
                    (0, ast_1.throwError)(`Incompatible types "${(0, types_1.printTypeRef)(le)}" and "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
                }
                if (r.name !== 'Int' && r.name !== 'Bool' && r.name !== 'Address' && r.name !== 'Cell' && r.name !== 'Slice' && r.name !== 'String') {
                    (0, ast_1.throwError)(`Invalid type "${r.name}" for binary operator "${exp.op}"`, exp.ref);
                }
            }
        }
        resolved = { kind: 'ref', name: 'Bool', optional: false };
    }
    else if (exp.op === '&&' || exp.op === '||') {
        if (le.kind !== 'ref' || le.optional || le.name !== 'Bool') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.ref);
        }
        if (re.kind !== 'ref' || re.optional || re.name !== 'Bool') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.ref);
        }
        resolved = { kind: 'ref', name: 'Bool', optional: false };
    }
    else {
        throw Error('Unsupported operator: ' + exp.op);
    }
    // Register result
    return registerExpType(ctx, exp, resolved);
}
function resolveUnaryOp(exp, sctx, ctx) {
    // Resolve right side
    ctx = resolveExpression(exp.right, sctx, ctx);
    // Check right type dependent on operator
    let resolvedType = getExpType(ctx, exp.right);
    if (exp.op === '-' || exp.op === '+') {
        if (resolvedType.kind !== 'ref' || resolvedType.optional || resolvedType.name !== 'Int') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(resolvedType)}" for unary operator "${exp.op}"`, exp.ref);
        }
    }
    else if (exp.op === '!') {
        if (resolvedType.kind !== 'ref' || resolvedType.optional || resolvedType.name !== 'Bool') {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(resolvedType)}" for unary operator "${exp.op}"`, exp.ref);
        }
    }
    else if (exp.op === '!!') {
        if (resolvedType.kind !== 'ref' || !resolvedType.optional) {
            (0, ast_1.throwError)(`Type "${(0, types_1.printTypeRef)(resolvedType)}" is not optional`, exp.ref);
        }
        resolvedType = { kind: 'ref', name: resolvedType.name, optional: false };
    }
    else {
        (0, ast_1.throwError)('Unknown operator ' + exp.op, exp.ref);
    }
    // Register result
    return registerExpType(ctx, exp, resolvedType);
}
function resolveField(exp, sctx, ctx) {
    // Resolve expression
    ctx = resolveExpression(exp.src, sctx, ctx);
    // Find target type and check for type
    const src = getExpType(ctx, exp.src);
    if (src === null || ((src.kind !== 'ref' || src.optional) && (src.kind !== 'ref_bounced'))) {
        (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for field access`, exp.ref);
    }
    // Check if field initialized
    if (sctx.requiredFields.length > 0 && exp.src.kind === 'id' && exp.src.value === 'self') {
        if (sctx.requiredFields.find((v) => v === exp.name)) {
            (0, ast_1.throwError)(`Field "${exp.name}" is not initialized`, exp.ref);
        }
    }
    // Find field
    let fields;
    const srcT = (0, resolveDescriptors_1.getType)(ctx, src.name);
    fields = srcT.fields;
    if (src.kind === 'ref_bounced') {
        fields = fields.slice(0, srcT.partialFieldCount);
    }
    const field = fields.find((v) => v.name === exp.name);
    const cst = srcT.constants.find((v) => v.name === exp.name);
    if (!field && !cst) {
        if (src.kind === 'ref_bounced') {
            (0, ast_1.throwError)(`Type bounced<"${src.name}"> does not have a field named "${exp.name}"`, exp.ref);
        }
        else {
            (0, ast_1.throwError)(`Type "${src.name}" does not have a field named "${exp.name}"`, exp.ref);
        }
    }
    // Register result type
    if (field) {
        return registerExpType(ctx, exp, field.type);
    }
    else {
        return registerExpType(ctx, exp, cst.type);
    }
}
function resolveStaticCall(exp, sctx, ctx) {
    // Check if abi global function
    if (global_1.GlobalFunctions[exp.name]) {
        const f = global_1.GlobalFunctions[exp.name];
        // Resolve arguments
        for (const e of exp.args) {
            ctx = resolveExpression(e, sctx, ctx);
        }
        // Resolve return type
        const resolved = f.resolve(ctx, exp.args.map((v) => getExpType(ctx, v)), exp.ref);
        // Register return type
        return registerExpType(ctx, exp, resolved);
    }
    // Check if function exists
    if (!(0, resolveDescriptors_1.hasStaticFunction)(ctx, exp.name)) {
        (0, ast_1.throwError)(`Static function "${exp.name}" does not exist`, exp.ref);
    }
    // Get static function
    const f = (0, resolveDescriptors_1.getStaticFunction)(ctx, exp.name);
    // Resolve call arguments
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Check arguments
    if (f.args.length !== exp.args.length) {
        (0, ast_1.throwError)(`Function "${exp.name}" expects ${f.args.length} arguments, got ${exp.args.length}`, exp.ref);
    }
    for (let i = 0; i < f.args.length; i++) {
        const a = f.args[i];
        const e = exp.args[i];
        const t = getExpType(ctx, e);
        if (!(0, isAssignable_1.isAssignable)(t, a.type)) {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument "${a.name}"`, e.ref);
        }
    }
    // Resolve return type
    return registerExpType(ctx, exp, f.returns);
}
function resolveCall(exp, sctx, ctx) {
    // Resolve expression
    ctx = resolveExpression(exp.src, sctx, ctx);
    // Check if self is initialized
    if (exp.src.kind === 'id' && exp.src.value === 'self' && (sctx.requiredFields.length > 0)) {
        (0, ast_1.throwError)('Cannot access self before init', exp.ref);
    }
    // Resolve args
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Resolve return value
    const src = getExpType(ctx, exp.src);
    if (src === null) {
        (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for function call`, exp.ref);
    }
    // Handle ref
    if (src.kind === 'ref') {
        if (src.optional) {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for function call`, exp.ref);
        }
        // Register return type
        const srcT = (0, resolveDescriptors_1.getType)(ctx, src.name);
        // Check struct ABI
        if (srcT.kind === 'struct') {
            const abi = struct_1.StructFunctions[exp.name];
            if (abi) {
                const resolved = abi.resolve(ctx, [src, ...exp.args.map((v) => getExpType(ctx, v))], exp.ref);
                return registerExpType(ctx, exp, resolved);
            }
        }
        const f = srcT.functions.get(exp.name);
        if (!f) {
            (0, ast_1.throwError)(`Type "${src.name}" does not have a function named "${exp.name}"`, exp.ref);
        }
        // Check arguments
        if (f.args.length !== exp.args.length) {
            (0, ast_1.throwError)(`Function "${exp.name}" expects ${f.args.length} arguments, got ${exp.args.length}`, exp.ref);
        }
        for (let i = 0; i < f.args.length; i++) {
            const a = f.args[i];
            const e = exp.args[i];
            const t = getExpType(ctx, e);
            if (!(0, isAssignable_1.isAssignable)(t, a.type)) {
                (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument "${a.name}"`, e.ref);
            }
        }
        return registerExpType(ctx, exp, f.returns);
    }
    // Handle map
    if (src.kind === 'map') {
        const abf = map_1.MapFunctions[exp.name];
        if (!abf) {
            (0, ast_1.throwError)(`Map function "${exp.name}" not found`, exp.ref);
        }
        const resolved = abf.resolve(ctx, [src, ...exp.args.map((v) => getExpType(ctx, v))], exp.ref);
        return registerExpType(ctx, exp, resolved);
    }
    if (src.kind === 'ref_bounced') {
        (0, ast_1.throwError)(`Cannot call function on bounced value`, exp.ref);
    }
    (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for function call`, exp.ref);
}
function resolveInitOf(ast, sctx, ctx) {
    // Resolve type
    const type = (0, resolveDescriptors_1.getType)(ctx, ast.name);
    if (type.kind !== 'contract') {
        (0, ast_1.throwError)(`Type "${ast.name}" is not a contract`, ast.ref);
    }
    if (!type.init) {
        (0, ast_1.throwError)(`Contract "${ast.name}" does not have an init function`, ast.ref);
    }
    // Resolve args
    for (const e of ast.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Check arguments
    if (type.init.args.length !== ast.args.length) {
        (0, ast_1.throwError)(`Init function of "${type.name}" expects ${type.init.args.length} arguments, got ${ast.args.length}`, ast.ref);
    }
    for (let i = 0; i < type.init.args.length; i++) {
        const a = type.init.args[i];
        const e = ast.args[i];
        const t = getExpType(ctx, e);
        if (!(0, isAssignable_1.isAssignable)(t, a.type)) {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument "${a.name}"`, e.ref);
        }
    }
    // Register return type
    return registerExpType(ctx, ast, { kind: 'ref', name: 'StateInit', optional: false });
}
exports.resolveInitOf = resolveInitOf;
function resolveConditional(ast, sctx, ctx) {
    // Resolve condition
    ctx = resolveExpression(ast.condition, sctx, ctx);
    const conditionType = getExpType(ctx, ast.condition);
    if (conditionType.kind !== 'ref' || conditionType.optional || conditionType.name !== 'Bool') {
        (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(conditionType)}" for ternary condition`, ast.condition.ref);
    }
    // Resolve then and else branches
    ctx = resolveExpression(ast.thenBranch, sctx, ctx);
    ctx = resolveExpression(ast.elseBranch, sctx, ctx);
    const thenType = getExpType(ctx, ast.thenBranch);
    const elseType = getExpType(ctx, ast.elseBranch);
    if (!(0, types_1.typeRefEquals)(thenType, elseType)) {
        (0, ast_1.throwError)(`Non-matching types "${(0, types_1.printTypeRef)(thenType)}" and "${(0, types_1.printTypeRef)(elseType)}" for ternary branches`, ast.elseBranch.ref);
    }
    // Register result
    return registerExpType(ctx, ast, thenType);
}
exports.resolveConditional = resolveConditional;
function resolveLValueRef(path, sctx, ctx) {
    const paths = path;
    let t = sctx.vars[paths[0].name];
    if (!t) {
        (0, ast_1.throwError)(`Variable "${paths[0].name}" not found`, paths[0].ref);
    }
    ctx = registerExpType(ctx, paths[0], t);
    // Paths
    for (let i = 1; i < paths.length; i++) {
        if (t.kind !== 'ref' || t.optional) {
            (0, ast_1.throwError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for field access`, path[i].ref);
        }
        const srcT = (0, resolveDescriptors_1.getType)(ctx, t.name);
        const ex = srcT.fields.find((v) => v.name === paths[i].name);
        if (!ex) {
            (0, ast_1.throwError)('Field ' + paths[i].name + ' not found in type ' + srcT.name, path[i].ref);
        }
        ctx = registerExpType(ctx, paths[i], ex.type);
        t = ex.type;
    }
    return ctx;
}
exports.resolveLValueRef = resolveLValueRef;
function resolveExpression(exp, sctx, ctx) {
    //
    // Literals
    //
    if (exp.kind === 'boolean') {
        return resolveBooleanLiteral(exp, sctx, ctx);
    }
    if (exp.kind === 'number') {
        return resolveIntLiteral(exp, sctx, ctx);
    }
    if (exp.kind === 'null') {
        return resolveNullLiteral(exp, sctx, ctx);
    }
    if (exp.kind === 'string') {
        return resolveStringLiteral(exp, sctx, ctx);
    }
    //
    // Constructors
    //
    if (exp.kind === 'op_new') {
        return resolveStructNew(exp, sctx, ctx);
    }
    //
    // Binary, unary and suffix operations
    //
    if (exp.kind === 'op_binary') {
        return resolveBinaryOp(exp, sctx, ctx);
    }
    if (exp.kind === 'op_unary') {
        return resolveUnaryOp(exp, sctx, ctx);
    }
    //
    // References
    //
    if (exp.kind === 'id') {
        // Find variable
        const v = sctx.vars[exp.value];
        if (!v) {
            if (!(0, resolveDescriptors_1.hasStaticConstant)(ctx, exp.value)) {
                (0, ast_1.throwError)('Unable to resolve id ' + exp.value, exp.ref);
            }
            else {
                const cc = (0, resolveDescriptors_1.getStaticConstant)(ctx, exp.value);
                return registerExpType(ctx, exp, cc.type);
            }
        }
        return registerExpType(ctx, exp, v);
    }
    if (exp.kind === 'op_field') {
        return resolveField(exp, sctx, ctx);
    }
    //
    // Function calls
    //
    if (exp.kind === 'op_static_call') {
        return resolveStaticCall(exp, sctx, ctx);
    }
    if (exp.kind === 'op_call') {
        return resolveCall(exp, sctx, ctx);
    }
    if (exp.kind === 'init_of') {
        return resolveInitOf(exp, sctx, ctx);
    }
    if (exp.kind === 'conditional') {
        return resolveConditional(exp, sctx, ctx);
    }
    throw Error('Unknown expression'); // Unreachable
}
exports.resolveExpression = resolveExpression;
function getAllExpressionTypes(ctx) {
    const res = [];
    const a = store.all(ctx);
    for (const e in a) {
        res.push([a[e].ast.ref.contents, (0, types_1.printTypeRef)(a[e].description)]);
    }
    return res;
}
exports.getAllExpressionTypes = getAllExpressionTypes;
